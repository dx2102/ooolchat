<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OoolChat</title>

  <!-- unocss + css reset -->
  <script>
    // configure unocss before loading the runtime
    window.__unocss = {
      shortcuts: {
        // 'mx-main': 'max-w-6xl mx-auto px-6 md:px-12 lg:px-20 xl:px-28',
        'mx-main': 'px-1/12 md:px-1/9',
      },
    }
  </script>
  <link fetchpriority="high" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@unocss/reset@0.60.0/tailwind.min.css">
  <script fetchpriority="high" src="https://cdn.jsdelivr.net/npm/@unocss/runtime@66.6.0"></script>
  <style>
    /* hide the page before unocss is ready */
    [un-cloak] {
      display: none !important;
    }
  </style>

  <!-- 
    unocss only set the css classes after DOMContentLoaded
    async/defer js tags still blocks this event
    We load other CPU/Network-heavy cdn libraries in js, 
    to make unocss work as fast as possible
  -->
  <!-- favicon as emoji -->
  <link rel="icon" href="data:image/svg+xml,
    <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
      <text x='0%' y='50%' style='text-anchor:center;dominant-baseline:central;font-size:100px;'>‚úèÔ∏è</text>
    </svg>
  ">



</head>

<body un-cloak class="flex h-dvh bg-white font-sans touch-manipulation">

  <aside
    class="text-base w-72 overflow-y-scroll flex-shrink-0  bg-gray-50 border-r border-gray-200 overflow-hidden flex flex-col">

    <div class="sticky top-0 px-2 py-1 bg-gray-50">
      <button id="newChatBtn" class="w-full py-2 px-3 rounded-lg bg-gray-50 hover:bg-gray-200 flex">
        ‚úèÔ∏è New Chat
      </button>
      <input type="text" id="searchInput" placeholder="üîé Search"
        class="w-full py-2 px-3 rounded-lg bg-gray-50 hover:bg-gray-200 placeholder-black focus:placeholder-gray-600 focus:outline-none">
    </div>

    <div class="px-2 flex-grow">
      <div class="pl-2 py-0 text-gray-300 select-none">Recent</div>
      <!-- sessionList here -->
      <div id="sessionList"></div>
      <div class="w-fit mx-auto text-2xl py-1 select-none">‚òÅÔ∏è</div>
    </div>

    <div class="sticky bottom-0 px-2 py-1 flex bg-gray-50 border-t  border-gray-200">
      <select id="modelSelector"
        class="flex-grow h-10 px-2 rounded-lg bg-gray-50 @hover:bg-gray-200 appearance-none focus:outline-none">
        <option value="google/gemini-3-flash-preview">üí° Gemini 3 Flash</option>
        <option value="x-ai/grok-4.1-fast">üí° Grok 4.1 Fast</option>
        <option value="deepseek/deepseek-r1-0528:free">üí° Deepseek R1 0528 (free)</option>
        <option value="moonshotai/kimi-k2.5">üí° Kimi K2.5</option>
      </select>
      <!-- <div class="my-1 border-l border-gray-300"></div> -->
      <button id="settingsBtn" title="Settings" class="w-10 h-10 rounded-lg bg-gray-100 @hover:bg-gray-200
        ">‚öôÔ∏è</button>
    </div>
  </aside>

  <!-- main chat area -->
  <!-- anchor for the input bar -->
  <div class="text-lg flex-grow overflow-y-scroll flex flex-col relative">
    <!-- scroll area inside the anchor -->
    <div class="flex-grow select-none">
      <!-- do mx-auto -->
      <div id="chatHistory" class="select-text mx-main  pt-8 pb-[40vh]  flex flex-col gap-4">
        <!-- chatHistory here -->
      </div>
    </div>

    <!-- input bar -->
    <label class="text-lg mx-main sticky bottom-0 left-0 right-0 flex flex-col-reverse">
      <!-- The bottom gap is bg-white. Must be below the shadow of input bar -->
      <div class="pb-4 pt-0.5 bg-white"></div>
      <!-- The top half of the bar, especially the rounded corner, is transparent -->
      <div style="
        background: linear-gradient(
        to bottom, 
        transparent 50%, 
        white 50%
      );">
        <!-- The textarea. Simply bg-white. -->
        <div class="flex items-center border border-gray-300 rounded-3xl shadow-sm bg-white">
          <textarea id="userInput"
            class="min-w-0 max-h-[40vh] flex-grow bg-transparent pl-5 pt-3 pb-3 pr-2  resize-none focus:outline-none placeholder:pl-0.5"
            rows="1" placeholder="Ask me anything"></textarea>
          <!-- 
            self-end keeps the button at the bottom when textarea grows, not in the middle
            m-2 makes the button centered when textarea is 1 line
            If input bar becomes text-base, we need m-1.5
          -->
          <button id="runLlmButton" class="bg-gray-800 text-white 
            rounded-full size-9 shrink-0 my-2 mr-2 self-end 
            flex items-center justify-center">
            ‚Üë
          </button>
        </div>
      </div>
    </label>
  </div>


  <script type="module">

    // --- DOM Elements ---
    const chatHistory = document.getElementById('chatHistory');
    const userInput = document.getElementById('userInput');
    const runLlmButton = document.getElementById('runLlmButton');

    const sessionList = document.getElementById('sessionList');
    const newChatBtn = document.getElementById('newChatBtn');
    const searchInput = document.getElementById('searchInput');
    const modelSelector = document.getElementById('modelSelector');
    const settingsBtn = document.getElementById('settingsBtn');



    // --- Global State ---
    let messages = [];
    let currentSessionId = null;
    let db = null;



    // autofocus
    setTimeout(() => {
      userInput.focus();
    }, 100);
    document.addEventListener('DOMContentLoaded', () => {
      userInput.focus();
    });
    // capture uneffective keydown events, when not focused on input
    document.addEventListener('keydown', (e) => {
      const activeEl = document.activeElement;
      if (activeEl.tagName === 'INPUT' ||
        activeEl.tagName === 'TEXTAREA' ||
        activeEl.isContentEditable) return;

      // allow pasting
      if ((e.ctrlKey || e.metaKey) && e.key == 'v') {
        userInput.focus();
        return;
      }

      // capture Enter
      if (e.key === 'Enter') {
        // trigger userInput keydown
        const event = new KeyboardEvent('keydown', {
          key: e.key, keyCode: e.keyCode,
          bubbles: false,
        });
        userInput.dispatchEvent(event);
        return;
      }

      if (e.ctrlKey || e.metaKey || e.altKey) return;

      if (window.getSelection().toString().length > 0) return;

      if (e.key.length === 1 && e.key !== ' ') {
        userInput.focus();
      }
    });


    // set up markdown styles with unocss
    const uno = window.__unocss_runtime.uno;
    const styles = {
      // w-full prevents code blocks from overflowing to the right
      '.prose': 'w-full leading-relaxed w-full max-w-none',

      '.prose h1': 'text-2xl font-semibold mt-4 mb-1',
      '.prose h2': 'text-xl font-semibold mt-4 mb-1',
      '.prose h3': 'text-lg font-semibold mt-4 mb-1',
      '.prose h4': 'text-lg font-semibold mt-4 mb-1',
      '.prose h5': 'text-lg font-semibold',
      '.prose h6': 'text-lg font-semibold',
      '.prose p': 'mt-2 mb-1',

      // text styles
      '.prose strong': 'font-semibold',
      '.prose em': 'italic',
      '.prose a': 'underline text-black font-semibold',
      '.prose blockquote': 'border-l-4 border-gray-300 pl-4 text-gray-800',
      '.prose hr': 'border-t border-gray-200 my-4',

      // lists
      '.prose ul': 'list-disc ml-6',
      '.prose ol': 'list-decimal ml-6',
      '.prose li': '',

      // '.prose table': 'table-auto w-full border-collapse text-left overflow-x-auto',

      // table
      '.prose table': 'mt-2 mb-1 w-full border-collapse table-auto',
      '.prose thead tr': ' border-b border-gray-300',
      '.prose tbody tr': 'border-b border-gray-200',
      '.prose tbody tr:last-child': 'border-b-0',
      '.prose tr': 'gap-2',
      '.prose th': 'py-2 px-2 text-left font-bold',
      '.prose td': 'py-2 px-2 text-left text-gray-900 ',
      '.prose th:first-child': 'pl-0',
      '.prose td:first-child': 'pl-0',
      '.prose th:last-child': 'pr-0',
      '.prose td:last-child': 'pr-0',

      // code
      '.prose code': 'bg-gray-100 p-1 rounded-lg',
      '.prose pre': 'bg-gray-50 p-4 rounded-lg max-w-full overflow-scroll',
      '.prose pre code': 'bg-transparent p-0 rounded-none',

      '.copy-btn': 'absolute top-2 right-2 px-2 py-1 rounded-lg bg-gray-100',
      '.copy-btn:hover': 'bg-gray-200',

      '.katex-display': 'overflow-x-auto',

    };

    async function loadCss() {
      const sheet = new CSSStyleSheet();
      let combinedRules = "";

      for (const [tag, className] of Object.entries(styles)) {
        const { css } = await uno.generate(className, { preflights: false });
        // for example: .m-2{margin:0.5rem;} 

        const tempSheet = new CSSStyleSheet();
        await tempSheet.replace(css);
        const styleBody = Array.from(tempSheet.cssRules)
          .map(rule => rule.style?.cssText || "")
          .join('\n');
        // for example: margin:0.5rem;
        // console.log(tag, className);
        // console.log(css);
        // console.log(styleBody);
        // console.log('---')

        combinedRules += `${tag} {\n${styleBody}\n}\n`;
      }

      // console.log(combinedRules)

      const styleEl = document.createElement('style');
      styleEl.textContent = combinedRules;
      document.head.appendChild(styleEl);
    }
    loadCss();


    // --- OpenAI Setup ---
    let openai = null;  // dynamic import in the background, while we set up the page
    async function loadOpenAI() {
      const OpenAI = (await import('https://cdn.skypack.dev/openai@6.9.1')).default;
      openai = new OpenAI({
        baseURL: 'https://openrouter.ai/api/v1',
        apiKey: localStorage.getItem('api-key'),
        dangerouslyAllowBrowser: true
      });
      window.openai = openai;
    }
    loadOpenAI();



    // --- Markdown Setup ---
    let mdRenderer = null;
    async function loadMarkdownLibs() {
      const urls = [
        // markdown-it
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js' },
        // highlight.js
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js' },
        { type: 'link', url: 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css' },
        // katex
        { type: 'link', url: 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css' },
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js' },
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/markdown-it-texmath@1.0.0/texmath.min.js' },
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js' }
      ];

      await Promise.all(urls.map(item => new Promise((resolve, reject) => {
        const el = document.createElement(item.type === 'script' ? 'script' : 'link');
        if (item.type === 'script') el.src = item.url;
        else { el.rel = 'stylesheet'; el.href = item.url; }
        el.onload = resolve;
        el.onerror = reject;
        document.head.appendChild(el);
      })));
      // console.log(window.markdownit, window.hljs, window.katex, window.texmath);

      mdRenderer = window.markdownit({
        html: true,
        highlight: function (str, lang) {
          if (lang && window.hljs.getLanguage(lang)) {
            try {
              return window.hljs.highlight(lang, str).value;
            } catch (e) {
              console.error(e);
            }
          }
          return ''; // use external default escaping
        }
      }).use(window.texmath, {
        engine: window.katex,
        delimiters: ['dollars', 'brackets', 'beg_end'],
        katexOptions: { macros: { "\\RR": "\\mathbb{R}" } }
      });

      /*
      In markdown-it (CommonMark), this will not be bolded:
      12**(3+4)**56
      ‰∏Ä‰∫å**Ôºà‰∏âÂõõÔºâ**‰∫îÂÖ≠
      ËøôÊòØ**Ôºà‰∏ÄÂ∞èÊÆµÔºâ**ÊñáÊú¨

      This will work correctly:
      Â∏¶Êúâ **‚ÄúÁ©∫Ê†º‚Äù** ÁöÑÂä†Á≤ó
      **ÔºàÊúÄÂ∑¶ËæπÁöÑÔºâ**Êã¨Âè∑

      Asterisks like text**punctuation without surrounding spaces will be skipped.
      This was to protect ** in math expressions, 
      but it breaks CJK formatting in the LLM output.

      markdown-it-cjk-friendly excludes CJK punctuation from this rule, by overwriting scanDelims in markdown-it.
      https://github.com/tats-u/markdown-cjk-friendly/blob/main/packages/markdown-it-cjk-friendly/src/index.ts
      */
      const patch = await import('https://cdn.jsdelivr.net/npm/markdown-it-cjk-friendly@2.0.1/+esm');
      mdRenderer = mdRenderer.use(patch.default);
    }
    loadMarkdownLibs();

    function renderMarkdown(text) {
      // text = fixCJK(text);
      let html = mdRenderer.render(text);
      // html = html.replaceAll('\u200B', '');
      // html = html.replaceAll('\x07', '');
      // html = html.replaceAll('ü•£', '');

      let dom = (new DOMParser()).parseFromString(html, 'text/html').body;

      // add copy buttons to pre
      dom.querySelectorAll('pre').forEach(pre => {
        const btn = document.createElement('button');
        btn.className = 'copy-btn absolute top-2 right-2 px-2 py-1 rounded-lg '
        btn.className += 'text-base bg-gray-100 text-gray-800 focus:outline-none ';
        btn.innerText = 'Copy';
        // mousedown is faster than click
        btn.onmousedown = () => {
          const text = pre.querySelector('code').innerText.trim();
          navigator.clipboard.writeText(text).then(() => {
            btn.innerText = 'Copied!';
            setTimeout(() => { btn.innerText = 'Copy'; }, 1000);
          });
        };
        pre.style.position = 'relative';
        pre.appendChild(btn);
      });
      return dom;
    }



    // --- IndexedDB Logic ---
    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('chat-db', 1);
        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains('sessions')) {
            db.createObjectStore('sessions', { keyPath: 'id' });
          }
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          // console.log(db)
          resolve(db);
        };
        request.onerror = (event) => reject(event.target.error);
      });
    }

    async function saveSessionToDB() {
      if (!db || messages.length === 0) return;

      if (!currentSessionId) {
        currentSessionId = Date.now().toString();
      }

      const firstUserMsg = messages.find(m => m.role === 'user');
      const maxTitleLength = 100;
      const rawTitle = firstUserMsg ? firstUserMsg.content : 'New Chat';
      const title = rawTitle.slice(0, maxTitleLength) + (rawTitle.length > maxTitleLength ? '...' : '');

      const session = {
        id: currentSessionId,
        updatedAt: Date.now(),
        title: title,
        messages: messages
      };

      return new Promise((resolve, reject) => {
        const tx = db.transaction('sessions', 'readwrite');
        const store = tx.objectStore('sessions');
        store.put(session);
        tx.oncomplete = () => {
          renderSidebar();
          resolve();
        };
        tx.onerror = () => reject(tx.error);
      });
    }

    async function loadAllSessions() {
      if (!db) return [];
      return new Promise((resolve) => {
        const tx = db.transaction('sessions', 'readonly');
        const store = tx.objectStore('sessions');
        const request = store.getAll();
        request.onsuccess = () => {
          const res = request.result.sort((a, b) => b.updatedAt - a.updatedAt);
          resolve(res);
        };
      });
    }

    async function loadSession(id) {
      return new Promise((resolve) => {
        const tx = db.transaction('sessions', 'readonly');
        const store = tx.objectStore('sessions');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
      });
    }

    // --- settings ui logic ---
    settingsBtn.addEventListener('mousedown', () => {
      const apiKey = prompt('Enter your OpenRouter API Key:');
      if (apiKey !== null && apiKey.trim() !== '') {
        localStorage.setItem('api-key', apiKey);
        openai.apiKey = apiKey;
      }
    });

    // --- sidebar ui logic ---

    function matchSession(keyword, session) {
      if (!keyword) return true;
      for (const msg of session.messages) {
        if (msg.content.toLowerCase().includes(keyword)) {
          return true;
        }
      }
      return false;
    }

    async function renderSidebar() {
      const sessions = await loadAllSessions();
      sessionList.innerHTML = '';

      const filter = searchInput.value.toLowerCase().trim();

      sessions.forEach(s => {
        if (!matchSession(filter, s)) return;

        const div = document.createElement('div');
        const isActive = s.id === currentSessionId;

        div.className = `p-2 rounded-lg cursor-pointer text-nowrap truncate select-none 
            ${isActive ? 'bg-gray-200' : '@hover:bg-gray-200'}`;
        div.innerText = s.title.replaceAll('\n', ' ') || 'New Chat';
        div.onmousedown = () => switchToSession(s.id);
        sessionList.appendChild(div);
      });
    }

    // ios safari might invalidate db connection when user comes back. Re-init on pageshow.
    async function resumePage(event) {
      console.log(event, document.visibilityState);
      userInput.dispatchEvent(new Event('input'))
      try {
        if (db) db.close();
        db = null;
      } catch (e) {
        console.error('Error closing db:', e);
      }
      await initDB();
      await renderSidebar();
    }
    window.addEventListener('visibilitychange', resumePage);
    window.addEventListener('pageshow', resumePage);

    function clearChat() {
      chatHistory.innerHTML = '';
      messages = [];
    }


    async function switchToSession(id) {
      const session = await loadSession(id);
      if (!session) return;

      currentSessionId = session.id;
      clearChat();
      messages = session.messages || [];
      messages.forEach(msg => appendMessage(msg.role, msg.content, false));
      renderSidebar();
      requestAnimationFrame(() => userInput.focus());
    }

    function createNewChat() {
      currentSessionId = null;
      clearChat();
      renderSidebar();
      requestAnimationFrame(() => userInput.focus());
    }

    function replaceDom(target, content) {
      // dfs DOM diffing for better ui
      // equivalent to: target.replaceChildren(...content.childNodes)
      const targetChildren = Array.from(target.childNodes);
      const contentChildren = Array.from(content.childNodes);

      contentChildren.forEach((newChild, i) => {
        const oldChild = targetChildren[i];

        // no old child -> append new child
        if (!oldChild) {
          target.appendChild(newChild.cloneNode(true));
          return;
        }

        // different nodeType/tagName -> cannot reuse old child, replace
        if (oldChild.nodeType !== newChild.nodeType || oldChild.tagName !== newChild.tagName) {
          target.replaceChild(newChild.cloneNode(true), oldChild);
          return;
        }

        // same nodeType/tagName -> update attributes and recurse
        if (oldChild.nodeType === Node.ELEMENT_NODE) {
          replaceAttributes(oldChild, newChild);
          replaceDom(oldChild, newChild);
        } else if (oldChild.nodeType === Node.TEXT_NODE) {
          // update text
          if (oldChild.textContent !== newChild.textContent) {
            oldChild.textContent = newChild.textContent;
          }
        }
      });

      // remove extra old children
      while (target.childNodes.length > contentChildren.length) {
        target.removeChild(target.lastChild);
      }
    }

    // aux function: sync attributes
    function replaceAttributes(target, content) {
      // remove old attributes not in content
      Array.from(target.attributes).forEach(attr => {
        if (!content.hasAttribute(attr.name)) {
          target.removeAttribute(attr.name);
        }
      });
      // set/update attributes from content
      Array.from(content.attributes).forEach(attr => {
        if (target.getAttribute(attr.name) !== attr.value) {
          target.setAttribute(attr.name, attr.value);
        }
      });
    }

    function appendMessage(role, content, isStreaming) {
      // auto-scroll is disabled by default
      // Check if user scrolled to bottom. If so we do auto-scroll after appending.
      // The scroll position is only accurate before we modify the DOM

      // const scrollBottom = chatHistory.scrollHeight - (chatHistory.scrollTop + chatHistory.clientHeight) < 10;
      const scrollBottom = false;

      let msgDiv;
      if (isStreaming) {
        msgDiv = document.getElementById('streaming-msg');
        if (!msgDiv) {
          msgDiv = document.createElement('div');
          msgDiv.id = 'streaming-msg';
          msgDiv.className = 'prose';
          chatHistory.appendChild(msgDiv);
        }
        // msgDiv.replaceChildren(renderMarkdown(content))
        replaceDom(msgDiv, renderMarkdown(content));
      } else {
        console.log(role, content);
        const wrapper = document.createElement('div');
        wrapper.className = `flex w-full ${role === 'user' ? 'justify-end' : 'justify-start'}`;

        const bubble = document.createElement('div');

        if (role === 'user') {
          bubble.className = 'bg-gray-100 px-4 py-2 rounded-2xl max-w-[80%] break-words whitespace-pre-wrap';
          bubble.innerText = content;
        } else {
          bubble.replaceChildren(renderMarkdown(content));
          bubble.className = 'prose';
        }

        wrapper.appendChild(bubble);
        chatHistory.appendChild(wrapper);
      }

      if (scrollBottom) {
        chatHistory.scrollTop = chatHistory.scrollHeight;
      }
    }



    // --- chat ui logic ---

    newChatBtn.onmousedown = createNewChat;
    searchInput.addEventListener('input', renderSidebar);


    async function nextAnimationFrame() {
      return new Promise(resolve => {
        requestAnimationFrame(resolve);
      });
    }

    // if user is in some input method (eg. Chinese), don't treat Enter as submit
    let isComposing = false;
    let isComposingChangeTime = -100;
    userInput.addEventListener('compositionstart', function () {
      // console.log('composition start')
      isComposing = true;
      isComposingChangeTime = performance.now();
    });
    userInput.addEventListener('compositionend', async function () {
      // console.log('composition end')
      isComposing = false;
      isComposingChangeTime = performance.now();
    });

    userInput.addEventListener('keydown', function (e) {
      // call API if Enter is pressed, but not Shift+Enter
      // console.log(e, e.key, e.isComposing)
      if (e.key === 'Enter' && !e.shiftKey) {
        if (isComposing || (performance.now() - isComposingChangeTime < 50)) {
          console.log(
            'skipped Enter due to composition',
            isComposing, isComposingChangeTime, performance.now(),
            performance.now() - isComposingChangeTime
          );
          return;
        }
        runLlm();
        e.preventDefault();  // don't insert newline
        // restore height to 1 line
        userInput.dispatchEvent(new Event('input'));
      }
    });

    // userInput.addEventListener('input', function (e) {
    //   // automatic textarea height
    //   userInput.style.height = 'auto';  // let the browser determine text height
    //   let height = userInput.scrollHeight;
    //   userInput.style.height = height + 'px';  // set new height

    //   setTimeout(() => {
    //     let height = userInput.scrollHeight;
    //     userInput.style.height = height + 'px';  // set new height
    //   }, 100);
    // });
    async function initAutosize() {
      const { default: autosize } = await import('https://cdn.jsdelivr.net/npm/autosize@6.0.1/+esm');
      autosize(userInput);
    }
    initAutosize();

    runLlmButton.onclick = runLlm;

    async function runLlm() {
      let text = userInput.value.trimEnd();
      const hasIndent = /\n /.test(text);
      if (!hasIndent) {
        text = text.trimStart();
      }

      if (!text) return;

      userInput.value = '';
      appendMessage('user', text);
      messages.push({ role: 'user', content: text });
      console.log(messages);

      runLlmButton.disabled = true;
      runLlmButton.classList.add('opacity-50');

      let fullResponse = '';
      try {
        const modelName = modelSelector.value;
        const stream = await openai.chat.completions.create({
          messages: messages,
          model: modelName,
          stream: true
        });

        for await (const chunk of stream) {
          const content = chunk.choices[0]?.delta?.content || '';
          console.log(content)
          fullResponse += content;
          appendMessage('assistant', fullResponse, true);
        }
      } catch (error) {
        // fullResponse += `\n\n>API Error: ${error.message}`;
        // appendMessage('assistant', fullResponse, true);
        alert(`API Error: ${error.message}`);
        console.error("API Error:", error);
      }

      const streamingDiv = document.getElementById('streaming-msg');
      if (streamingDiv) streamingDiv.removeAttribute('id');

      messages.push({ role: 'assistant', content: fullResponse });
      runLlmButton.disabled = false;
      runLlmButton.classList.remove('opacity-50');

      await saveSessionToDB();
    }



  </script>
</body>

</html>
