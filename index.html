<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OoolChat</title>
  <meta name="description" content="The clean and fast LLM chat interface.">

  <script>
    let erudaCounter = 0;
    function loadEruda() {
      erudaCounter++;
      console.log("Eruda counter:", erudaCounter);
      if (erudaCounter !== 5) {
        return;
      }
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/eruda@3.4.3/eruda.min.js';
      script.onload = () => {
        eruda.init();
        console.log('Eruda loaded');
      };
      document.body.appendChild(script);
    }
  </script>

  <!-- font awsome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css">

  <!-- UnoCSS + CSS Reset -->
  <script>
    // configure unocss before loading the runtime
    window.__unocss = {
      shortcuts: {
        'scrollbar-hide': '[ms-overflow-style:none] [scrollbar-width:none] [&::-webkit-scrollbar]:hidden',
        'container-main': '[container-type:inline-size] [container-name:main]',
      },
      variants: [
        (matcher) => {
          if (!matcher.startsWith('main-lg:')) return matcher
          return {
            matcher: matcher.slice('main-lg:'.length),
            parent: `@container main (min-width: 768px)`,
          }
        }
      ]
    }

    // add scrollbar-hide to root
    document.documentElement.classList.add('scrollbar-hide');

  </script>
  <style>
    /* hide the page before unocss is ready */
    [un-cloak] {
      display: none !important;
    }
  </style>
  <link fetchpriority="high" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@unocss/reset@0.60.0/tailwind.min.css">
  <script fetchpriority="high" src="https://cdn.jsdelivr.net/npm/@unocss/runtime@66.6.0"></script>

  <style>
    @container main (min-width: 1px) {
      .px-main {
        padding-inline: 1rem
      }
    }

    @container main (min-width: 768px) {
      .px-main {
        padding-inline: max(3.5rem, calc(100% - 768px) / 2)
      }
    }
  </style>
  <!-- 
    unocss only set the css classes after DOMContentLoaded
    async/defer js tags still blocks this event
    We load other CPU/Network-heavy cdn libraries in js, 
    to make unocss work as fast as possible
  -->
  <!-- favicon as emoji -->
  <link rel="icon" href="data:image/svg+xml,
    <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
      <text x='0%' y='50%' style='text-anchor:center;dominant-baseline:central;font-size:100px;'>‚úèÔ∏è</text>
    </svg>
  ">



</head>

<body un-cloak class="relative text-lg flex h-dvh bg-white font-sans touch-manipulation no-scrollbar">
  <!-- 
    h-dvh: "device height". Different from h-screen.
    In iOS Safari the browser bar can resize and take extra height.
    h-dvh can make the website's height shrink accordingly, 
    instead of overflowing like h-screen do.

    touch-manipulation: disable "double-tap to zoom" for mobile devices

    The "@hover:" below is a unocss feature. It won't trigger on touch devices.
  -->
  <aside id="sideBar" class="
    text-base w-72 overflow-y-scroll flex-shrink-0
    bg-gray-50 border-r border-gray-200 flex flex-col

    fixed left-0 top-0 bottom-0 shadow-2xl z-10
    sm:static sm:shadow-none
    ">
    <!-- 
    sticky is better than flex/absolute because it can bubble scroll events upwards.
    user can scroll the sidebar even when the mouse is over buttons.
    -->
    <div class="sticky top-0 mx-2 py-1 bg-gray-50">
      <button id="newChatBtn" class="w-full py-2 px-3 rounded-lg bg-gray-50 @hover:bg-gray-200 flex">
        ‚úèÔ∏è New Chat
      </button>
      <input type="text" id="searchInput" placeholder="üîé Search"
        class="w-full py-2 px-3 rounded-lg bg-gray-50 @hover:bg-gray-200 placeholder-black focus:placeholder-gray-600 focus:outline-none">
    </div>

    <div class="px-2 flex-grow">
      <div class="pl-2 text-gray-300 select-none" onclick="loadEruda()">Recent</div>
      <!-- sessionList here -->
      <div id="sessionList"></div>
      <div class="w-fit mx-auto text-2xl py-1 select-none">‚òÅÔ∏è</div>
    </div>

    <div class="sticky bottom-0 px-2 pt-1 flex flex-col bg-gray-50 border-t  border-gray-200">
      <div class="flex">
        <label for="modelSelector" class="sr-only">Select Model</label>
        <select id="modelSelector"
          class="flex-grow min-w-0 h-10 px-2 rounded-lg bg-gray-50 @hover:bg-gray-200 appearance-none focus:outline-none">
          <option value="google/gemini-3-flash-preview">üí° Gemini 3 Flash</option>
          <option value="z-ai/glm-5">üí° GLM 5</option>
          <option value="x-ai/grok-4.1-fast">üí° Grok 4.1 Fast</option>
          <option value="deepseek/deepseek-r1-0528:free">üí° Deepseek R1 0528 (free)</option>
          <option value="moonshotai/kimi-k2.5">üí° Kimi K2.5</option>
        </select>
        <button id="settingsBtn" title="Settings" class="w-10 h-10 rounded-lg  @hover:bg-gray-200
        ">‚öôÔ∏è</button>
      </div>
      <div class="flex">
        <a class="h-10 pl-2 text-gray-300 font-semibold flex items-center select-none" 
          target="_blank">
          <p>OoolChat</p>
        </a>
        <div class="flex-grow"></div>
        <button id="foldBtn" title="Fold Sidebar" class="w-10 h-10 text-lg rounded-lg @hover:bg-gray-200
        ">¬´</button>
      </div>
    </div>
  </aside>

  <!-- main chat area -->
  <!-- anchor for the input bar -->
  <main id="mainChat" class="flex-grow overflow-y-scroll flex flex-col container-main">
    <!-- small sideBar2 -->
    <div class="absolute z-10 top-0 left-0 right-0 main-lg:p-1">
      <div id="sideBar2" class="
        flex p-1 bg-white
        main-lg:flex-col main-lg:p-0 main-lg:bg-gray-50 main-lg:rounded-lg main-lg:w-fit
      ">
        <button id="newChatBtn2" class="w-10 h-10 rounded-lg @hover:bg-gray-200">‚úèÔ∏è</button>
        <button id="foldBtn2" class="w-10 h-10 rounded-lg @hover:bg-gray-200">¬ª</button>
      </div>
    </div>

    <div class="flex-grow select-none relative">
      <div id="chatHistory" class="select-text pt-12 px-main flex flex-col gap-4">
        <!-- chatHistory here -->
      </div>
    </div>



    <!-- 
    input bar. 

    This is sticky and min-h-[50vh] so it creates a 1/2 screen margin below the main.

    The textarea never grows beyond 50vh, so the input bar won't cover the main elements.
    As the textarea grows, the height of label is still 50vh, 
    so the main does not resize, and the scrollbar does not show up.

    The label tag: All untriggered click events in label (including the padding areas) 
    will trigger the textarea focus().
    -->
    <label class="h-[50vh] px-main shrink-0 pointer-events-none sticky bottom-0 left-0 right-0 flex flex-col-reverse">
      <!-- The bottom gap is bg-white. Must be below the shadow of input bar -->
      <div class="pb-[1em] bg-white pointer-events-auto"></div>
      <!-- The top half of the bar, especially the rounded corner, is transparent -->
      <div class=" pointer-events-auto" style="
        background: linear-gradient(
        to bottom, 
        transparent 50%, 
        white 50%
      );">
        <!-- The textarea. Simply bg-white. -->
        <div class="flex items-center border border-gray-300 rounded-3xl shadow-sm bg-white">
          <textarea id="userInput"
            class="min-w-0 max-h-[calc(50vh-3em)]  overflow-y-scroll flex-grow bg-transparent pl-5 pt-3 pb-3 pr-2  resize-none focus:outline-none placeholder:pl-0.5"
            rows="1" placeholder="Ask me anything"></textarea>
          <!-- 
            self-end keeps the button at the bottom when textarea grows, not in the middle
            m-2 makes the button centered when textarea is 1 line
            If input bar becomes text-base, we need m-1.5
          -->
          <button id="runLlmButton" class="bg-gray-800 text-white 
            rounded-full size-9 shrink-0 my-2 mr-2 self-end 
            flex items-center justify-center ">
            ‚Üë
          </button>
        </div>
      </div>
    </label>
  </main>


  <script defer type="module">

    // --- DOM Elements ---
    const chatHistory = document.getElementById('chatHistory');
    const userInput = document.getElementById('userInput');
    const runLlmButton = document.getElementById('runLlmButton');

    const sessionList = document.getElementById('sessionList');
    const newChatBtn = document.getElementById('newChatBtn');
    const searchInput = document.getElementById('searchInput');
    const modelSelector = document.getElementById('modelSelector');
    const settingsBtn = document.getElementById('settingsBtn');
    const foldBtn = document.getElementById('foldBtn');

    const newChatBtn2 = document.getElementById('newChatBtn2');
    const foldBtn2 = document.getElementById('foldBtn2');

    const mainChat = document.getElementById('mainChat');
    const sideBar = document.getElementById('sideBar');
    const sideBar2 = document.getElementById('sideBar2');



    // --- Global State ---
    let messages = [];
    let currentSessionId = null;
    let db = null;



    function isMobile() {
      // return window.innerWidth < 640;
      return window.matchMedia("(max-width: 640px)").matches;
    }
    const isAndroid = window.navigator.userAgent.toLowerCase().includes('android');
    const canHover = window.matchMedia("(hover: hover)").matches;

    // view management
    let isFolded = false;
    function foldChanged() {
      if (isFolded) {
        // Folded: hide sidebar, show shidebar2/main
        sideBar.style.display = 'none';
        sideBar2.style.display = 'flex';
      } else {
        // Unfolded:
        // show sidebar/main, hide sidebar2
        // sidebar will be stacked on top of main on mobile
        sideBar.style.display = 'flex';
        sideBar2.style.display = 'none';
      }
    }
    foldChanged();
    foldBtn.addEventListener('mousedown', () => {
      isFolded = true;
      foldChanged();
    });
    foldBtn2.addEventListener('mousedown', (e) => {
      isFolded = false;
      foldChanged();
      e.stopPropagation();  // prevent triggering mainChat mousedown
    });
    mainChat.addEventListener('mousedown', () => {
      // for sm: devices, sidebar is stacked on top of the main. Clicks on main can fold the sidebar
      if (!isFolded && isMobile()) {
        isFolded = true;
        foldChanged();
      }
    });



    // autofocus
    function inputFocus() {
      // prevent android phones from poping up the virtual keyboard
      // iOS browsers already block focus by default
      if (isAndroid && !canHover) return;
      requestAnimationFrame(() => userInput.focus());
    }
    setTimeout(() => {
      inputFocus();
    }, 100);
    document.addEventListener('DOMContentLoaded', () => {
      inputFocus();
    });
    // capture uneffective keydown events, when not focused on input
    document.addEventListener('keydown', (e) => {
      const activeEl = document.activeElement;
      if (activeEl.tagName === 'INPUT' ||
        activeEl.tagName === 'TEXTAREA' ||
        activeEl.isContentEditable) return;

      // allow pasting
      if ((e.ctrlKey || e.metaKey) && e.key == 'v') {
        inputFocus();
        return;
      }

      // capture Enter
      if (e.key === 'Enter') {
        // trigger userInput keydown
        const event = new KeyboardEvent('keydown', {
          key: e.key, keyCode: e.keyCode,
          bubbles: false,
        });
        userInput.dispatchEvent(event);
        return;
      }

      if (e.ctrlKey || e.metaKey || e.altKey) return;

      if (window.getSelection().toString().length > 0) return;

      if (e.key.length === 1) {
        inputFocus();
      }
      if (e.key === ' ') {
        inputFocus();
        e.preventDefault();
      }
    });



    // set up markdown styles with unocss
    const uno = window.__unocss_runtime.uno;
    const styles = {
      // w-full prevents code blocks from overflowing to the right
      '.prose': 'w-full leading-relaxed w-full max-w-none',

      '.prose h1': 'text-2xl font-semibold mt-4 mb-1',
      '.prose h2': 'text-xl font-semibold mt-4 mb-1',
      '.prose h3': 'text-lg font-semibold mt-4 mb-1',
      '.prose h4': 'text-lg font-semibold mt-4 mb-1',
      '.prose h5': 'text-lg font-semibold',
      '.prose h6': 'text-lg font-semibold',
      '.prose p': 'mt-2 mb-1',

      // text styles
      '.prose strong': 'font-semibold',
      '.prose em': 'italic',
      '.prose a': 'underline text-black font-semibold',
      '.prose blockquote': 'border-l-4 border-gray-300 pl-4 text-gray-800',
      '.prose hr': 'border-t border-gray-200 my-4',

      // lists
      '.prose ul': 'list-disc ml-6',
      '.prose ol': 'list-decimal ml-6',
      '.prose li': '',

      // '.prose table': 'table-auto w-full border-collapse text-left overflow-x-auto',

      // table
      '.prose table': 'mt-2 mb-1 w-full border-collapse table-auto',
      '.prose thead tr': 'border-b border-gray-300',
      '.prose tbody tr': 'border-b border-gray-200',
      '.prose tbody tr:last-child': 'border-b-0',
      '.prose th': 'py-2 px-2 text-left font-bold',
      '.prose td': 'py-2 px-2 text-left text-gray-900 ',
      '.prose th:first-child': 'pl-0',
      '.prose td:first-child': 'pl-0',
      '.prose th:last-child': 'pr-0',
      '.prose td:last-child': 'pr-0',

      // code
      '.prose code': 'bg-gray-100 p-1 rounded-lg',
      '.prose pre': 'bg-gray-50 p-4 rounded-lg max-w-full overflow-scroll',
      '.prose pre code': 'bg-transparent p-0 rounded-none',

      '.copy-btn': 'absolute top-2 right-2 px-2 py-1 rounded-lg bg-gray-100',
      '.copy-btn:hover': 'bg-gray-200',

      '.katex-display': 'overflow-x-auto overflow-y-hidden',
    };

    async function loadCss() {
      const sheet = new CSSStyleSheet();
      let combinedRules = "";

      for (const [tag, className] of Object.entries(styles)) {
        const { css } = await uno.generate(className, { preflights: false });
        /*
        uno = window.__unocss_runtime.uno;
        (await uno.generate('h-40vh', { preflights: false })).css
        */
        // for example: .m-2{margin:0.5rem;} 

        const tempSheet = new CSSStyleSheet();
        await tempSheet.replace(css);
        const styleBody = Array.from(tempSheet.cssRules)
          .map(rule => rule.style?.cssText || "")
          .join('\n');
        // for example: margin:0.5rem;
        // console.log(tag, className);
        // console.log(css);
        // console.log(styleBody);
        // console.log('---')

        combinedRules += `${tag} {\n${styleBody}\n}\n`;
      }

      // console.log(combinedRules)

      const styleEl = document.createElement('style');
      styleEl.textContent = combinedRules;
      document.head.appendChild(styleEl);
    }
    loadCss();


    // --- OpenAI Setup ---
    let openai = null;  // dynamic import in the background, while we set up the page
    async function loadOpenAI() {
      const OpenAI = (await import('https://cdn.skypack.dev/openai@6.9.1')).default;
      openai = new OpenAI({
        baseURL: 'https://openrouter.ai/api/v1',
        apiKey: localStorage.getItem('api-key'),
        dangerouslyAllowBrowser: true
      });
      window.openai = openai;
    }
    loadOpenAI();



    // --- Markdown Setup ---
    let mdRenderer = null;
    async function loadMarkdownLibs() {
      const urls = [
        // markdown-it
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js' },
        // highlight.js
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js' },
        { type: 'link', url: 'https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css' },

        // { type: 'script', url: 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js' },
        // { type: 'link', url: 'https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css' },
        // katex
        { type: 'link', url: 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css' },
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js' },
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/markdown-it-texmath@1.0.0/texmath.min.js' },
        { type: 'script', url: 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js' }
      ];

      await Promise.all(urls.map(item => new Promise((resolve, reject) => {
        const el = document.createElement(item.type === 'script' ? 'script' : 'link');
        if (item.type === 'script') {
          el.src = item.url;
        } else {
          el.rel = 'stylesheet'; el.href = item.url;
        }
        el.onload = resolve;
        el.onerror = reject;
        document.head.appendChild(el);
      })));
      // console.log(window.markdownit, window.hljs, window.katex, window.texmath);

      mdRenderer = window.markdownit({
        html: false,
        linkify: true,
        breaks: true,
        highlight: function (str, lang) {
          if (lang && window.hljs.getLanguage(lang)) {
            try {
              return window.hljs.highlight(lang, str).value;
            } catch (e) {
              console.error(e);
            }
          }
          return ''; // use external default escaping
        }
      }).use(window.texmath, {
        engine: window.katex,
        delimiters: ['dollars', 'brackets', 'beg_end'],
        katexOptions: { macros: { "\\RR": "\\mathbb{R}" } }
      });

      /*
      In markdown-it (CommonMark), this will not be bolded:
      12**(3+4)**56
      ‰∏Ä‰∫å**Ôºà‰∏âÂõõÔºâ**‰∫îÂÖ≠
      ËøôÊòØ**Ôºà‰∏ÄÂ∞èÊÆµÔºâ**ÊñáÊú¨

      This will work correctly:
      Â∏¶Êúâ **‚ÄúÁ©∫Ê†º‚Äù** ÁöÑÂä†Á≤ó
      **ÔºàÊúÄÂ∑¶ËæπÁöÑÔºâ**Êã¨Âè∑

      Asterisks like text**punctuation without surrounding spaces will be skipped.
      This was to protect ** in math expressions, 
      but it breaks CJK formatting in the LLM output.

      markdown-it-cjk-friendly excludes CJK punctuation from this rule, by overwriting scanDelims in markdown-it.
      https://github.com/tats-u/markdown-cjk-friendly/blob/main/packages/markdown-it-cjk-friendly/src/index.ts
      */
      const patch = await import('https://cdn.jsdelivr.net/npm/markdown-it-cjk-friendly@2.0.1/+esm');
      mdRenderer = mdRenderer.use(patch.default);
    }
    loadMarkdownLibs();

    function renderMarkdown(text) {
      let html = mdRenderer.render(text);
      let dom = (new DOMParser()).parseFromString(html, 'text/html').body;

      // wrap table into div with display:block to enable horizontal scrolling
      dom.querySelectorAll('table').forEach(table => {
        const div = document.createElement('div');
        div.className = 'overflow-x-auto max-w-full block';
        table.parentNode.insertBefore(div, table);
        div.appendChild(table);
      });

      // add copy buttons to pre
      dom.querySelectorAll('pre').forEach(pre => {
        const btn = document.createElement('button');
        btn.className = 'copy-btn absolute top-2 right-2 px-2 py-1 rounded-lg '
        btn.className += 'text-base bg-gray-100 text-gray-800 focus:outline-none ';
        btn.innerText = 'Copy';
        // mousedown is faster than click
        btn.onmousedown = () => {
          console.log('copy code');
          const text = pre.querySelector('code').innerText.trim();
          navigator.clipboard.writeText(text).then(() => {
            btn.innerText = 'Copied!';
            setTimeout(() => { btn.innerText = 'Copy'; }, 1000);
          });
        };
        pre.style.position = 'relative';
        pre.appendChild(btn);
      });
      return dom;
    }



    // --- IndexedDB Logic ---
    async function initDB() {
      console.log('init db')
      if (db) {
        try {
          const tx = db.transaction('sessions', 'readonly');
          if (tx) {
            console.log('DB connection is healthy. Skipping re-init.');
            return db;
          }
        } catch (e) {
          console.error('Error testing db connection:', e);
        }
      }
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('chat-db', 1);
        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains('sessions')) {
            db.createObjectStore('sessions', { keyPath: 'id' });
          }
        };
        request.onsuccess = (event) => {
          db = event.target.result;
          // console.log(db)
          resolve(db);
        };
        request.onerror = (event) => reject(event.target.error);
      });
    }

    async function saveSessionToDB() {
      if (!db || messages.length === 0) return;

      if (!currentSessionId) {
        currentSessionId = Date.now().toString();
      }

      const firstUserMsg = messages.find(m => m.role === 'user');
      const maxTitleLength = 100;
      const rawTitle = firstUserMsg ? firstUserMsg.content : 'New Chat';
      const title = rawTitle.slice(0, maxTitleLength) + (rawTitle.length > maxTitleLength ? '...' : '');

      const session = {
        id: currentSessionId,
        updatedAt: Date.now(),
        title: title,
        messages: messages
      };

      return new Promise((resolve, reject) => {
        const tx = db.transaction('sessions', 'readwrite');
        const store = tx.objectStore('sessions');
        store.put(session);
        tx.oncomplete = () => {
          renderSidebar();
          resolve();
        };
        tx.onerror = () => reject(tx.error);
      });
    }

    async function loadAllSessions() {
      if (!db) return [];
      return new Promise((resolve) => {
        const tx = db.transaction('sessions', 'readonly');
        const store = tx.objectStore('sessions');
        const request = store.getAll();
        request.onsuccess = () => {
          const res = request.result.sort((a, b) => b.updatedAt - a.updatedAt);
          resolve(res);
        };
      });
    }

    async function loadSession(id) {
      return new Promise((resolve) => {
        const tx = db.transaction('sessions', 'readonly');
        const store = tx.objectStore('sessions');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
      });
    }

    // --- settings ui logic ---
    settingsBtn.addEventListener('mousedown', () => {
      const apiKey = prompt('Enter your OpenRouter API Key:');
      if (apiKey !== null && apiKey.trim() !== '') {
        localStorage.setItem('api-key', apiKey);
        openai.apiKey = apiKey;
      }
    });

    // --- sidebar ui logic ---

    function matchSession(keyword, session) {
      if (!keyword) return true;
      for (const msg of session.messages) {
        if (msg.content.toLowerCase().includes(keyword)) {
          return true;
        }
      }
      return false;
    }

    async function renderSidebar() {
      const sessions = await loadAllSessions();
      sessionList.innerHTML = '';

      const filter = searchInput.value.toLowerCase().trim();

      sessions.forEach(s => {
        if (!matchSession(filter, s)) return;

        const div = document.createElement('div');
        const isActive = s.id === currentSessionId;

        div.className = `p-2 rounded-lg cursor-pointer text-nowrap truncate select-none 
            ${isActive ? 'bg-gray-200' : '@hover:bg-gray-200'}`;
        div.innerText = s.title.replaceAll('\n', ' ') || 'New Chat';
        div.onmousedown = () => switchToSession(s.id);
        sessionList.appendChild(div);
      });
    }

    // ios safari might invalidate db connection when user comes back. Re-init on pageshow.
    async function resumePage(event) {
      // console.log('resuming page for event:', event);
      userInput.dispatchEvent(new Event('input'))
      await initDB();
      await renderSidebar();
    }
    resumePage();
    window.addEventListener('pageshow', resumePage);
    // seems like db open() is never resolved in the 'invisible' stage before the page shows up

    function clearChat() {
      chatHistory.innerHTML = '';
      messages = [];
    }


    async function switchToSession(id) {
      const session = await loadSession(id);
      if (!session) return;

      currentSessionId = session.id;
      clearChat();
      messages = session.messages || [];
      messages.forEach(msg => appendMessage(msg.role, msg.content, false));
      requestAnimationFrame(() => inputFocus());
      renderSidebar();
      if (!isFolded && isMobile()) {
        isFolded = true;
        foldChanged();
      }
    }

    function createNewChat() {
      currentSessionId = null;
      clearChat();
      renderSidebar();
      requestAnimationFrame(() => inputFocus());
    }

    function replaceDom(target, content) {
      // dfs DOM diffing to minimize DOM operations
      // equivalent to: target.replaceChildren(...content.childNodes)
      // some children in target will directly point to content instead of cloning
      // to preserve js event listeners
      const targetChildren = Array.from(target.childNodes);
      const contentChildren = Array.from(content.childNodes);

      contentChildren.forEach((newChild, i) => {
        const oldChild = targetChildren[i];

        // no old child -> append new child
        if (!oldChild) {
          // target.appendChild(newChild.cloneNode(true));
          target.appendChild(newChild);
          return;
        }

        // different nodeType/tagName -> cannot reuse old child, replace
        if (oldChild.nodeType !== newChild.nodeType || oldChild.tagName !== newChild.tagName) {
          // target.replaceChild(newChild.cloneNode(true), oldChild);
          target.replaceChild(newChild, oldChild);
          return;
        }

        // same nodeType/tagName -> update attributes and recurse
        if (oldChild.nodeType === Node.ELEMENT_NODE) {
          replaceAttributes(oldChild, newChild);
          replaceDom(oldChild, newChild);
        } else if (oldChild.nodeType === Node.TEXT_NODE) {
          // update text
          if (oldChild.textContent !== newChild.textContent) {
            oldChild.textContent = newChild.textContent;
          }
        }
      });

      // remove redundant old children
      while (target.childNodes.length > contentChildren.length) {
        target.removeChild(target.lastChild);
      }
    }

    // aux function: sync attributes
    function replaceAttributes(target, content) {
      // remove old attributes not in content
      Array.from(target.attributes).forEach(attr => {
        if (!content.hasAttribute(attr.name)) {
          target.removeAttribute(attr.name);
        }
      });
      // set/update attributes from content
      Array.from(content.attributes).forEach(attr => {
        if (target.getAttribute(attr.name) !== attr.value) {
          target.setAttribute(attr.name, attr.value);
        }
      });
    }

    function appendMessage(role, content, isStreaming) {
      // auto-scroll is disabled by default
      // Check if user scrolled to bottom. If so we do auto-scroll after appending.
      // The scroll position is only accurate before we modify the DOM

      // const scrollBottom = chatHistory.scrollHeight - (chatHistory.scrollTop + chatHistory.clientHeight) < 10;
      const scrollBottom = false;

      let msgDiv;
      if (isStreaming) {
        msgDiv = document.getElementById('streaming-msg');
        if (!msgDiv) {
          msgDiv = document.createElement('div');
          msgDiv.id = 'streaming-msg';
          msgDiv.className = 'prose';
          chatHistory.appendChild(msgDiv);
        }
        // msgDiv.replaceChildren(renderMarkdown(content))
        replaceDom(msgDiv, renderMarkdown(content));
      } else {
        console.log(role, content);
        const wrapper = document.createElement('div');
        wrapper.className = `flex w-full ${role === 'user' ? 'justify-end' : 'justify-start'}`;

        const bubble = document.createElement('div');

        if (role === 'user') {
          bubble.className = 'bg-gray-100 px-4 py-2 rounded-2xl max-w-[80%] break-words whitespace-pre-wrap';
          bubble.innerText = content;
        } else {
          bubble.replaceChildren(renderMarkdown(content));
          bubble.className = 'prose';
        }

        wrapper.appendChild(bubble);
        chatHistory.appendChild(wrapper);
      }

      if (scrollBottom) {
        chatHistory.scrollTop = chatHistory.scrollHeight;
      }
    }



    // --- chat ui logic ---

    newChatBtn.onmousedown = createNewChat;
    newChatBtn2.onmousedown = createNewChat;
    searchInput.addEventListener('input', renderSidebar);


    async function nextAnimationFrame() {
      return new Promise(resolve => {
        requestAnimationFrame(resolve);
      });
    }

    userInput.addEventListener('keydown', function (e) {
      // call API if Enter is pressed, but not Shift+Enter
      // console.log(e.isComposing, e.key, e.keyCode)
      if (e.key === 'Enter' && !e.shiftKey) {
        if (e.isComposing || e.keyCode === 229) {
          // key code 229 is deprecated, but e.isComposing does not behave well in safari
          console.log(
            'skipped Enter due to composition',
            e.isComposing, e.key, e.keyCode
          );
          return;
        }
        runLlm();
        e.preventDefault();  // don't insert newline
      }
    });

    function assert(condition) {
      if (!condition) {
        throw new Error('Assertion failed');
      }
    }

    // userInput.addEventListener('input', async function (e) {
    //   // automatic textarea height
    //   const h1 = userInput.style.height;
    //   const h2 = userInput.scrollHeight + 'px';

    //   userInput.style.height = 'auto';  // let the browser determine text height

    //   const h3 = userInput.style.height;  // -> auto
    //   const h4 = userInput.scrollHeight + 'px';

    //   console.log('input event', h1, h2, h3, h4)
    //   if (h1 !== h4) {
    //     userInput.style.height = h4;
    //   }
    // });
    async function initAutosize() {
      const { default: autosize } = await import('https://cdn.jsdelivr.net/npm/autosize@6.0.1/+esm');
      autosize(userInput);
    }
    initAutosize();
    // async function initScrollbar() {
    //   const { default: SimpleBar } = await import('https://cdn.jsdelivr.net/npm/simplebar@6.2.3/+esm');
    //   new SimpleBar(userInput, { autoHide: false });
    // }
    // initScrollbar();
    userInput.addEventListener('input', (e) => {
      // scroll to bottom if cursor is at the end
      const cursorPosition = userInput.selectionStart;
      const textLength = userInput.value.length;
      if (cursorPosition === textLength) {
        console.log('bottom')
        userInput.scrollTop = 999999;
      }
    });


    runLlmButton.onclick = runLlm;

    function fullStringify(obj) {
      return JSON.stringify(obj, Object.getOwnPropertyNames(obj), 2);
    }

    async function runLlm() {
      let text = userInput.value.trimEnd();
      const hasIndent = /\n /.test(text);
      if (!hasIndent) {
        text = text.trimStart();
      }

      if (!text) return;

      userInput.value = '';
      // restore height to 1 line when we modify the value
      userInput.dispatchEvent(new Event('input'));

      appendMessage('user', text);
      messages.push({ role: 'user', content: text });
      console.log(messages);

      runLlmButton.disabled = true;
      runLlmButton.classList.add('opacity-50');

      let fullResponse = '';
      try {
        const modelName = modelSelector.value;
        const stream = await openai.chat.completions.create({
          messages: messages,
          model: modelName,
          stream: true
        });

        for await (const chunk of stream) {
          console.log(chunk.choices[0]);
          const content = chunk.choices[0]?.delta?.content || '';
          const think = chunk.choices[0]?.delta?.reasoning || '';
          console.log(content, think)
          fullResponse += think + content;
          appendMessage('assistant', fullResponse, true);

          let reason = chunk.choices[0]?.finish_reason || '' 
          if (reason !== '' && reason !== 'stop') {
            reason += chunk.choices[0]?.native_finish_reason || ''
            throw new Error(`Finished. Reason: ${reason}`);
          }
        }
      } catch (error) {
        // fullResponse += `\n\n>API Error: ${error.message}`;
        // appendMessage('assistant', fullResponse, true);

        // alert(`API Error:\n${error.message}\n\nHeaders:\n${fullStringify(error.headers)}`);
        alert(`API Error:\n${error?.message}\n\n${error?.error?.metadata?.raw}`);
        console.error("API Error:", error, error?.message, error?.error?.metadata?.raw);
      }

      const streamingDiv = document.getElementById('streaming-msg');
      if (streamingDiv) streamingDiv.removeAttribute('id');

      messages.push({ role: 'assistant', content: fullResponse });
      runLlmButton.disabled = false;
      runLlmButton.classList.remove('opacity-50');

      await saveSessionToDB();
    }



  </script>
</body>

</html>
